# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0

# Any publicly available image
image: public.ecr.aws/docker/library/python:3.13-bookworm

# Change pip's cache directory to be inside the project directory since we can
# only cache local items.
# variables:
#   PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# https://pip.pypa.io/en/stable/topics/caching/
# cache:
#   paths:
#     - .cache/pip

stages:
  - developer_tests
  - integration_tests
  - deployment_validation

developer_tests:
  stage: developer_tests
  rules:
    - when: always  # Run on all branches
  
  before_script:
    - python --version
    - apt-get update -y
    - apt-get install make -y
    - pip install ruff
    # Install dependencies needed by publish.py for test imports
    - pip install typer rich boto3
    # Install test dependencies
    - cd lib/idp_common_pkg && pip install -e ".[test]" && cd ../..

  script:
    - make lint-cicd
    - make test-cicd -C lib/idp_common_pkg
  
  artifacts:
    paths:
      - lib/idp_common_pkg/test-reports/coverage.xml
      - lib/idp_common_pkg/test-reports/test-results.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: lib/idp_common_pkg/test-reports/coverage.xml
      junit: lib/idp_common_pkg/test-reports/test-results.xml
    expire_in: 1 week

integration_tests:
  stage: integration_tests
  # variables:
  #   # In order to run tests in another account, add a AWS_CREDS_TARGET_ROLE variable to the Gitlab pipeline variables.
  #   AWS_CREDS_TARGET_ROLE: ${AWS_CREDS_TARGET_ROLE}
  #   AWS_DEFAULT_REGION: ${AWS_DEFAULT_REGION}
  #   IDP_ACCOUNT_ID: ${IDP_ACCOUNT_ID}
  
 # Add rules to only run on develop branch
 # Add rules to only run on develop branch
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: always # always # When idp-accelerator CICD is reconfigured
    - if: $CI_COMMIT_BRANCH =~ /^feature\/.*/
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^fix\/.*/
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*/
      when: manual
    - if: $CI_COMMIT_BRANCH =~ /^release\/.*/
      when: manual
    - when: manual  # This will make it available on all other branches

  before_script:
    - python --version
    - apt-get update -y
    - apt-get install zip unzip curl make -y
       
    # Install Poetry
    - curl -sSL https://install.python-poetry.org | python3 -
    - export PATH="/root/.local/bin:$PATH"
    - poetry --version

    # Install AWS CLI
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip
    - ./aws/install

  script:
    - aws --version
    - aws sts get-caller-identity --no-cli-pager
    - cd ./scripts/sdlc/idp-cli
    - poetry install
    - make put
    - make wait

deployment_validation:
  stage: deployment_validation
  rules:
    - when: always

  before_script:
    - apt-get update -y
    - apt-get install curl unzip python3-pip -y
    # Install AWS CLI
    - curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    - unzip awscliv2.zip
    - ./aws/install
    # Install PyYAML for template analysis
    - pip install PyYAML

  script:
    # Check if service role has sufficient permissions for main stack deployment
    - |
      python3 -c "
      import yaml
      import sys
      import os
      import glob

      def extract_aws_services_from_template(template_path):
          '''Extract AWS services used in a CloudFormation template'''
          try:
              with open(template_path, 'r') as f:
                  template = yaml.safe_load(f)
              
              services = set()
              if 'Resources' in template:
                  for resource in template['Resources'].values():
                      if 'Type' in resource:
                          resource_type = resource['Type']
                          if resource_type.startswith('AWS::'):
                              service = resource_type.split('::')[1].lower()
                              services.add(service)
              return services
          except Exception as e:
              print(f'Error processing {template_path}: {e}')
              return set()

      def extract_permissions_from_role(role_template_path):
          '''Extract permissions from IAM role template'''
          with open(role_template_path, 'r') as f:
              role_template = yaml.safe_load(f)
          
          permissions = set()
          for resource in role_template['Resources'].values():
              if resource['Type'] == 'AWS::IAM::Role':
                  for policy in resource['Properties']['Policies']:
                      for statement in policy['PolicyDocument']['Statement']:
                          if statement['Effect'] == 'Allow':
                              actions = statement['Action']
                              if isinstance(actions, str):
                                  permissions.add(actions)
                              else:
                                  permissions.update(actions)
          return permissions

      # Extract permissions from service role
      role_permissions = extract_permissions_from_role('iam-roles/cloudformation-management/IDP-Cloudformation-Service-Role.yaml')

      # Find all CloudFormation templates
      template_files = []
      template_files.append('template.yaml')  # Main template
      template_files.extend(glob.glob('patterns/*/template.yaml'))
      template_files.extend(glob.glob('options/*/template.yaml'))

      # Extract required services from all templates
      required_services = set()
      for template_file in template_files:
          if os.path.exists(template_file):
              services = extract_aws_services_from_template(template_file)
              required_services.update(services)
              print(f'Services in {template_file}: {sorted(services)}')

      print(f'\\nAll required services: {sorted(required_services)}')

      # Check if role has permissions for each service
      missing_services = []
      for service in required_services:
          # Check if role has wildcard or specific permissions for this service
          has_permission = any(
              perm == f'{service}:*' or 
              perm.startswith(f'{service}:') or
              perm == '*'
              for perm in role_permissions
          )
          if not has_permission:
              missing_services.append(service)

      if missing_services:
          print(f'\\nWARNING: Service role may be missing permissions for: {sorted(missing_services)}')
          sys.exit(1)
      else:
          print(f'\\nSUCCESS: Service role appears to have sufficient permissions for all required services')
      "
  
